# 📌 FAANG Interview Study Plan  

## Overview  
- **Algorithm Practice**: Solve **5 easy, 5 medium, and 2 hard** tasks per topic (approx. **1 week per topic**).  
- **System Design**: Spend **~1 week per topic**.  
- **Behavioral Interview**: Prepare **~3 stories per day**.  

---

## 📚 Algorithm Core  

### 🔹 Sliding Window  
**Use case:** Problems related to **subarrays, substrings, or sequences** in an array.  

**📝 Theory:**  
- [ ] Link 1  
- [ ] Link 2 *(to be added as I start)*

**📝 Practice:**  
- [ ] Task 1  
- [ ] Task 2 *(to be added as I start)*  

### 🔹 Two Pointers  
**Use case:** Helpful when working with **sorted arrays or linked lists** to find **pairs, triplets, or partitions

### 🔹 Fast & Slow Pointers (Floyd’s Cycle Detection)  
**Use case:** Finding cycles in linked lists or repeating sequences.

### 🔹 Merge Intervals 
**Use case:** When dealing with overlapping ranges. 

### 🔹 Binary Search
**Use case:** When working with sorted arrays or when trying to minimize/maximize a function. 

### 🔹 Bit Manipulation  
**Use case:** When working with binary numbers or optimizing space. 

### 🔹 Backtracking  
**Use case:** When you need to explore multiple possibilities recursively

### 🔹 Dynamic Programming (DP)  
**Use case:** When a problem can be broken down into overlapping subproblems

### 🔹 Greedy Algorithms  
**Use case:** When choosing the best local option leads to the global solution

### 🔹 Graph Traversal (DFS & BFS)
**Use case:** When working with grids, trees, or connected components.

### 🔹 Union-Find (Disjoint Set)
**Use case:** When dealing with connectivity problems

### 🔹 Heap (Priority Queue)
**Use case:** When you need to get the smallest/largest element quickly

### 🔹 Prefix Sum & Difference Arrays
**Use case:** When querying subarray sums efficiently.

### 🔹 Topological Sorting (Kahn’s Algorithm)
**Use case:** When working with dependencies (DAG). 

### 🔹 Trie (Prefix Tree)
**Use case:** When dealing with dictionary words, autocomplete, or prefix matching. 

### 🔹 Monotonic Stack / Queue
**Use case:** Finding next/previous greater/smaller elements efficiently. 

### 🔹 Segment Tree & Fenwick Tree
**Use case:** When handling range queries efficiently. 

---

## 📌 JavaScript Core  

### 🔹 Closures & Lexical Scope  
**Definition:** JavaScript functions retain access to their **parent scope**, even after execution. Useful for:  
✔️ Private variables  
✔️ Memoization  
✔️ Callbacks  

**✅ Key Concepts:**  
- Function scope & block scope  
- Lexical environment  
- Practical use cases (e.g., function factories, event handlers)  

**📝 Tasks:**  
- [ ] Task 1  
- [ ] Task 2 *(to be added as I start)*  

### 🔹 Promises & Async/Await  
**Definition:** JavaScript is asynchronous, and handling operations like **API calls, `setTimeout`**, and event listeners efficiently is crucial.  

**✅ Key Concepts:**  
- Promises (`resolve`, `reject`, chaining)  
- Async/Await (handling async code)  
- Error handling (`.catch()`, `try/catch`)  

---

## 🏗️ System Design Topics  

### Internet & HTTP Basics  
**✅ Key Concepts:**  
✔️ HTTP vs. HTTPS (SSL/TLS, encryption)  
✔️ REST vs. GraphQL vs. gRPC  
✔️ Status Codes & Methods (GET, POST, PUT, DELETE)  
✔️ DNS & CDN  
✔️ CORS (Cross-Origin Resource Sharing)  
✔️ Rate Limiting & API Throttling  

### Accessibility (A11Y) & User Experience  
**🔹 Why?** Building **inclusive, user-friendly systems** improves usability and compliance.  

**✅ Key Concepts:**  
✔️ WCAG Guidelines  
✔️ ARIA Roles & Semantic HTML  
✔️ Keyboard Navigation & Focus Management  
✔️ Screen Readers & Assistive Technologies  
✔️ Color Contrast & Dark Mode Support  
